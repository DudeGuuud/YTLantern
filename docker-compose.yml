services:
  # Frontend (Next.js) - Server-side rendered
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend
    container_name: ytlantern-frontend
    environment:
      - NODE_ENV=production
      - BACKEND_URL=http://backend:8000
    restart: unless-stopped

  # Backend (FastAPI)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: ytlantern-backend
    environment:
      - HOST=0.0.0.0
      - PORT=8000
      - DEBUG=false
      - REDIS_URL=redis://redis:6379/0
      - VIDEO_STORAGE_PATH=/app/videos
      - CORS_ORIGINS=http://localhost:${EXTERNAL_HTTP_PORT:-8080},https://yourdomain.com
      - MAX_MEMORY_MB=1024
    volumes:
      - video_storage:/app/videos
    depends_on:
      - redis
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis (Caching)
  redis:
    image: redis:7-alpine
    container_name: ytlantern-redis
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 5s
      retries: 3

  # Nginx (Reverse Proxy)
  nginx:
    image: nginx:alpine
    container_name: ytlantern-nginx
    ports:
      - "${EXTERNAL_HTTP_PORT:-8080}:80"
      - "${EXTERNAL_HTTPS_PORT:-8443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - nginx_cache:/var/cache/nginx
      - ./ssl:/etc/ssl:ro  # Mount SSL certificates if available
    depends_on:
      - frontend
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 5s
      retries: 3

  # Cleanup service
  cleanup:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: ytlantern-cleanup
    environment:
      - REDIS_URL=redis://redis:6379/0
      - VIDEO_STORAGE_PATH=/app/videos
      - CLEANUP_INTERVAL=3600  # 1 hour
      - MAX_VIDEO_AGE=86400    # 24 hours
      - MAX_MEMORY_MB=512
    volumes:
      - video_storage:/app/videos
    depends_on:
      - redis
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    command: >
      python -c "
      import asyncio;
      import os;
      import time;
      from pathlib import Path;

      async def cleanup_loop():
          video_path = Path(os.getenv('VIDEO_STORAGE_PATH', '/app/videos'));
          cleanup_interval = int(os.getenv('CLEANUP_INTERVAL', '3600'));
          max_age = int(os.getenv('MAX_VIDEO_AGE', '86400'));

          while True:
              try:
                  current_time = time.time();
                  cleaned = 0;

                  if video_path.exists():
                      for file_path in video_path.rglob('*'):
                          if file_path.is_file():
                              file_age = current_time - file_path.stat().st_mtime;
                              if file_age > max_age:
                                  file_path.unlink();
                                  cleaned += 1;

                  print(f'Cleanup completed: {cleaned} old files removed');
              except Exception as e:
                  print(f'Cleanup error: {e}');

              await asyncio.sleep(cleanup_interval);

      asyncio.run(cleanup_loop())
      "

volumes:
  video_storage:
    driver: local
  redis_data:
    driver: local
  nginx_cache:
    driver: local

networks:
  default:
    name: ytlantern-network
